Index: ext/openssl/ossl_asn1.c
--- ext/openssl/ossl_asn1.c.orig
+++ ext/openssl/ossl_asn1.c
@@ -24,9 +24,9 @@ asn1time_to_time(const ASN1_TIME *time)
 
     memset(&tm, 0, sizeof(struct tm));
 
-    switch (time->type) {
+    switch (ASN1_STRING_type(time)) {
     case V_ASN1_UTCTIME:
-	count = sscanf((const char *)time->data, "%2d%2d%2d%2d%2d%2dZ",
+	count = sscanf((const char *)ASN1_STRING_get0_data(time), "%2d%2d%2d%2d%2d%2dZ",
 		&tm.tm_year, &tm.tm_mon, &tm.tm_mday, &tm.tm_hour, &tm.tm_min,
 		&tm.tm_sec);
 
@@ -34,7 +34,7 @@ asn1time_to_time(const ASN1_TIME *time)
 	    tm.tm_sec = 0;
 	} else if (count != 6) {
 	    ossl_raise(rb_eTypeError, "bad UTCTIME format: \"%s\"",
-		    time->data);
+		    ASN1_STRING_get0_data(time));
 	}
 	if (tm.tm_year < 69) {
 	    tm.tm_year += 2000;
@@ -43,7 +43,7 @@ asn1time_to_time(const ASN1_TIME *time)
 	}
 	break;
     case V_ASN1_GENERALIZEDTIME:
-	count = sscanf((const char *)time->data, "%4d%2d%2d%2d%2d%2dZ",
+	count = sscanf((const char *)ASN1_STRING_get0_data(time), "%4d%2d%2d%2d%2d%2dZ",
 		&tm.tm_year, &tm.tm_mon, &tm.tm_mday, &tm.tm_hour, &tm.tm_min,
 		&tm.tm_sec);
 	if (count == 5) {
@@ -51,7 +51,7 @@ asn1time_to_time(const ASN1_TIME *time)
 	}
 	else if (count != 6) {
 		ossl_raise(rb_eTypeError, "bad GENERALIZEDTIME format: \"%s\"",
-			time->data);
+			ASN1_STRING_get0_data(time));
 	}
 	break;
     default:
@@ -96,7 +96,7 @@ ossl_time_split(VALUE time, time_t *sec, int *days)
 VALUE
 asn1str_to_str(const ASN1_STRING *str)
 {
-    return rb_str_new((const char *)str->data, str->length);
+    return rb_str_new((const char *)ASN1_STRING_get0_data(str), ASN1_STRING_length(str));
 }
 
 /*
@@ -111,7 +111,7 @@ asn1integer_to_num(const ASN1_INTEGER *ai)
     if (!ai) {
 	ossl_raise(rb_eTypeError, "ASN1_INTEGER is NULL!");
     }
-    if (ai->type == V_ASN1_ENUMERATED)
+    if (ASN1_STRING_type(ai) == V_ASN1_ENUMERATED)
 	/* const_cast: workaround for old OpenSSL */
 	bn = ASN1_ENUMERATED_to_BN((ASN1_ENUMERATED *)ai, NULL);
     else
@@ -214,9 +214,8 @@ obj_to_asn1bstr(VALUE obj, long unused_bits)
     StringValue(obj);
     if(!(bstr = ASN1_BIT_STRING_new()))
 	ossl_raise(eASN1Error, NULL);
-    ASN1_BIT_STRING_set(bstr, (unsigned char *)RSTRING_PTR(obj), RSTRING_LENINT(obj));
-    bstr->flags &= ~(ASN1_STRING_FLAG_BITS_LEFT|0x07); /* clear */
-    bstr->flags |= ASN1_STRING_FLAG_BITS_LEFT | unused_bits;
+    if (!ASN1_BIT_STRING_set1(bstr, (unsigned char *)RSTRING_PTR(obj), RSTRING_LENINT(obj), (int)unused_bits))
+	ossl_raise(eASN1Error, NULL);
 
     return bstr;
 }
@@ -344,17 +343,17 @@ decode_bstr(unsigned char* der, long length, long *unu
 {
     ASN1_BIT_STRING *bstr;
     const unsigned char *p;
-    long len;
+    size_t len;
+    int unused;
     VALUE ret;
 
     p = der;
     if(!(bstr = d2i_ASN1_BIT_STRING(NULL, &p, length)))
 	ossl_raise(eASN1Error, NULL);
-    len = bstr->length;
-    *unused_bits = 0;
-    if(bstr->flags & ASN1_STRING_FLAG_BITS_LEFT)
-	*unused_bits = bstr->flags & 0x07;
-    ret = rb_str_new((const char *)bstr->data, len);
+    if(!ASN1_BIT_STRING_get_length(bstr, &len, &unused))
+        ossl_raise(eASN1Error, NULL);
+    *unused_bits = unused;
+    ret = rb_str_new((const char *)ASN1_STRING_get0_data(bstr), len);
     ASN1_BIT_STRING_free(bstr);
 
     return ret;
