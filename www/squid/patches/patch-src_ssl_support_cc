Index: src/ssl/support.cc
--- src/ssl/support.cc.orig
+++ src/ssl/support.cc
@@ -272,23 +272,23 @@ ParseSubjectAltName(const GENERAL_NAME &san)
 
         // RFC 5280 section 4.2.1.6 signals IPv4/IPv6 address family using data length
 
-        if (san.d.iPAddress->length == 4) {
+        if (ASN1_STRING_length(san.d.iPAddress) == 4) {
             struct in_addr addr;
             static_assert(sizeof(addr.s_addr) == 4);
-            memcpy(&addr.s_addr, san.d.iPAddress->data, sizeof(addr.s_addr));
+            memcpy(&addr.s_addr, ASN1_STRING_get0_data(san.d.iPAddress), sizeof(addr.s_addr));
             const Ip::Address ip(addr);
             return AnyP::Host::ParseIp(ip);
         }
 
-        if (san.d.iPAddress->length == 16) {
+        if (ASN1_STRING_length(san.d.iPAddress) == 16) {
             struct in6_addr addr;
             static_assert(sizeof(addr.s6_addr) == 16);
-            memcpy(&addr.s6_addr, san.d.iPAddress->data, sizeof(addr.s6_addr));
+            memcpy(&addr.s6_addr, ASN1_STRING_get0_data(san.d.iPAddress), sizeof(addr.s6_addr));
             const Ip::Address ip(addr);
             return AnyP::Host::ParseIp(ip);
         }
 
-        debugs(83, 3, "unexpected length of an IP address SAN: " << san.d.iPAddress->length);
+        debugs(83, 3, "unexpected length of an IP address SAN: " << ASN1_STRING_length(san.d.iPAddress));
         return std::nullopt;
     }
 
@@ -647,7 +647,7 @@ Ssl::VerifyCallbackParameters::At(Security::Connection
 }
 
 // "dup" function for SSL_get_ex_new_index("cert_err_check")
-#if OPENSSL_VERSION_MAJOR >= 3
+#if OPENSSL_VERSION_MAJOR >= 3 || defined(LIBRESSL_VERSION_NUMBER)
 static int
 ssl_dupAclChecklist(CRYPTO_EX_DATA *, const CRYPTO_EX_DATA *, void **,
                     int, long, void *)
@@ -1484,7 +1484,7 @@ void Ssl::InRamCertificateDbKey(const Ssl::Certificate
     if (certProperties.mimicCert) {
         if (auto *sig = Ssl::X509_get_signature(certProperties.mimicCert)) {
             origSignatureAsKey = true;
-            key.append((const char *)sig->data, sig->length);
+            key.append((const char *)ASN1_STRING_get0_data(sig), ASN1_STRING_length(sig));
         }
     }
 
