Don't use store, replace SSL_CIPHER_standard_name() by existing API and
don't try to run EVP_DigestInit() with NULL md, this ends in tears.

Index: src/ne_openssl.c
--- src/ne_openssl.c.orig
+++ src/ne_openssl.c
@@ -86,7 +86,7 @@ typedef const unsigned char ne_d2i_uchar;
 #define EVP_PKEY_get0_RSA(evp) (evp->pkey.rsa)
 #endif
 
-#if OPENSSL_VERSION_NUMBER >= 0x10101000
+#if OPENSSL_VERSION_NUMBER >= 0x10101000 && !defined(LIBRESSL_VERSION_NUMBER)
 /* OpenSSL 1.1.1 has STORE. */
 #define HAVE_OPENSSL111
 #include <openssl/store.h>
@@ -128,18 +128,18 @@ static int append_dirstring(ne_buffer *buf, ASN1_STRIN
     unsigned char *tmp = (unsigned char *)""; /* initialize to workaround 0.9.6 bug */
     int len;
 
-    switch (str->type) {
+    switch (ASN1_STRING_type(str)) {
     case V_ASN1_IA5STRING: /* definitely ASCII */
     case V_ASN1_VISIBLESTRING: /* probably ASCII */
     case V_ASN1_PRINTABLESTRING: /* subset of ASCII */
-        ne_buffer_qappend(buf, str->data, str->length);
+        ne_buffer_qappend(buf, ASN1_STRING_get0_data(str), ASN1_STRING_length(str));
         break;
     case V_ASN1_UTF8STRING:
         /* Fail for embedded NUL bytes. */
-        if (strlen((char *)str->data) != (size_t)str->length) {
+        if (strlen((char *)ASN1_STRING_get0_data(str)) != (size_t)ASN1_STRING_length(str)) {
             return -1;
         }
-        ne_buffer_append(buf, (char *)str->data, str->length);
+        ne_buffer_append(buf, (char *)ASN1_STRING_get0_data(str), ASN1_STRING_length(str));
         break;
     case V_ASN1_UNIVERSALSTRING:
     case V_ASN1_T61STRING: /* let OpenSSL convert it as ISO-8859-1 */
@@ -163,7 +163,7 @@ static int append_dirstring(ne_buffer *buf, ASN1_STRIN
         break;
     default:
         NE_DEBUG(NE_DBG_SSL, "Could not convert DirectoryString type %d\n",
-                 str->type);
+                 ASN1_STRING_type(str));
         return -1;
     }
     return 0;
@@ -173,7 +173,7 @@ static int append_dirstring(ne_buffer *buf, ASN1_STRIN
  * safety. */
 static char *dup_ia5string(const ASN1_IA5STRING *as)
 {
-    return ne_strnqdup(as->data, as->length);
+    return ne_strnqdup(ASN1_STRING_get0_data(as), ASN1_STRING_length(as));
 }
 
 char *ne_ssl_readable_dname(const ne_ssl_dname *name)
@@ -230,22 +230,23 @@ void ne_ssl_clicert_free(ne_ssl_client_cert *cc)
 static time_t asn1time_to_timet(const ASN1_TIME *atm)
 {
     struct tm tm = {0};
-    int i = atm->length;
+    const unsigned char *data = ASN1_STRING_get0_data(atm);
+    int i = ASN1_STRING_length(atm);
     
     if (i < 10)
         return (time_t )-1;
 
-    tm.tm_year = FROM_DEC(atm->data);
+    tm.tm_year = FROM_DEC(data);
 
     /* Deal with Year 2000 */
     if (tm.tm_year < 70)
         tm.tm_year += 100;
 
-    tm.tm_mon = FROM_DEC(atm->data + 2) - 1;
-    tm.tm_mday = FROM_DEC(atm->data + 4);
-    tm.tm_hour = FROM_DEC(atm->data + 6);
-    tm.tm_min = FROM_DEC(atm->data + 8);
-    tm.tm_sec = FROM_DEC(atm->data + 10);
+    tm.tm_mon = FROM_DEC(data + 2) - 1;
+    tm.tm_mday = FROM_DEC(data + 4);
+    tm.tm_hour = FROM_DEC(data + 6);
+    tm.tm_min = FROM_DEC(data + 8);
+    tm.tm_sec = FROM_DEC(data + 10);
 
 #ifdef HAVE_TIMEZONE
     /* ANSI C time handling is... interesting. */
@@ -302,10 +303,10 @@ static int check_identity(const struct host_info *serv
             else if (nm->type == GEN_IPADD && server && server->literal) {
                 /* compare IP addfress with server literal IP address. */
                 ne_inet_addr *ia;
-                if (nm->d.ip->length == 4)
-                    ia = ne_iaddr_make(ne_iaddr_ipv4, nm->d.ip->data);
-                else if (nm->d.ip->length == 16)
-                    ia = ne_iaddr_make(ne_iaddr_ipv6, nm->d.ip->data);
+                if (ASN1_STRING_length(nm->d.ip) == 4)
+                    ia = ne_iaddr_make(ne_iaddr_ipv4, ASN1_STRING_data(nm->d.ip));
+                else if (ASN1_STRING_length(nm->d.ip) == 16)
+                    ia = ne_iaddr_make(ne_iaddr_ipv6, ASN1_STRING_data(nm->d.ip));
                 else
                     ia = NULL;
                 /* ne_iaddr_make returns NULL if address type is unsupported */
@@ -316,7 +317,7 @@ static int check_identity(const struct host_info *serv
                 } else {
                     NE_DEBUG(NE_DBG_SSL, "iPAddress name with unsupported "
                              "address type (length %d), skipped.\n",
-                             nm->d.ip->length);
+                             ASN1_STRING_length(nm->d.ip));
                 }
             }
         }
@@ -795,7 +796,7 @@ int ne__negotiate_ssl(ne_session *sess)
         const SSL_CIPHER *ciph = SSL_get_current_cipher(ssl);
 
         sess->status.hs.protocol = ne_sock_getproto(sess->socket);
-        sess->status.hs.ciphersuite = SSL_CIPHER_standard_name(ciph);
+        sess->status.hs.ciphersuite = SSL_CIPHER_get_name(ciph);
         sess->notify_cb(sess->notify_ud, ne_status_handshake, &sess->status);
     }
 
@@ -1358,6 +1359,8 @@ char *ne_vstrhash(unsigned int flags, va_list ap)
     unsigned char v[EVP_MAX_MD_SIZE];
     unsigned int vlen;
     const char *arg;
+
+    if (!md) return NULL;
 
     ctx = EVP_MD_CTX_new();
     if (!ctx) return NULL;
